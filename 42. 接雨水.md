# 42. 接雨水

## 解题思路

### On的解法


* 初始化：首先检查输入数组height的长度，如果为0，则直接返回0，因为没有墙壁，自然不可能积累雨水。

* 动态规划存储：接着，创建两个数组l_max和r_max来分别存储每个位置左侧和右侧最高墙的高度。数组的长度与输入的height数组相同。

* 基础情况设置：将l_max的第一个元素设置为height[0]，因为第一个位置的左侧没有其他墙，所以左侧最高墙就是其本身。同理，将r_max的最后一个元素设置为height[n - 1]。

* 从左向右计算l_max：从第二个位置开始，遍历height数组，更新l_max数组，l_max[i]为height[i]和l_max[i-1]中的最大值，表示到当前位置为止，左侧的最高墙。

* 从右向左计算r_max：从倒数第二个位置开始，向左遍历，更新r_max数组，r_max[i]为height[i]和r_max[i+1]中的最大值，表示到当前位置为止，右侧的最高墙。

* 计算积水量：遍历每个位置，除了最左和最右外，因为这两个位置不可能积水。对于每个位置i，可以积累的雨水量为min(l_max[i], r_max[i]) - height[i]。min(l_max[i], r_max[i])表示在当前位置，左右两边墙中较矮的一个的高度，这决定了这个位置最多能积多少水，然后减去当前位置自身的高度，就得到了该位置能积累的雨水量。将所有位置的积水量累加起来，就得到了总的积水量。

```java
class Solution {
    public int trap(int[] height) {
        if(height.length == 0){
            return 0;
        }

        int n = height.length;
        int res = 0;


        // 数组当作备忘录 记录答案
        int[] l_max = new int[n];
        int[] r_max = new int[n];

        // 初始化base case
        l_max[0] = height[0];
        r_max[n - 1] = height[n - 1];


        // 从左向右开始计算 l_max
        for(int i = 1; i < n; i++){
            l_max[i] = Math.max(height[i],l_max[i - 1]);
        }


        // 从右向左计算r _max
        for(int i  = n  -2; i>=0; i--){
            r_max[i] = Math.max(height[i],r_max[i + 1]);
        }


        // 计算最终答案  将每一个位置的最大水柱高度累加
        for(int i = 1; i < n - 1; i++){
            res += Math.min(l_max[i],r_max[i]) - height[i];
        }

        return res;
    }
}

```


### 双指针解法

* 初始化指针和变量：初始化两个指针left和right分别指向数组的开始和结束位置。同时，初始化l_max和r_max为0，分别用来记录遍历过程中遇到的左侧和右侧的最大高度。

* 双指针遍历：当left指针小于right指针时，执行循环。这表示还有未检查的元素。

* 更新左右最大值：在每次循环中，更新l_max和r_max为左右两侧目前遇到的最大高度。

* 计算积水并移动指针：
class Solution {
    public void sortColors(int[] nums) {
        // 排序 从小到大 然后相同的元素需要在一起


        // 双指针交换
        int n = nums.length;
        int p1 = 0;
        int p2 = n - 1;

        for(int i = 0; i < n; i++){

            // 当前元素为2的时候 与p2位置进行交换 将数字2移动到数组的末尾
            // 交换后，i的位置上现在是原来p2位置上的元素。
            // 此时，这个新到i位置的元素还没有被检查，因此不能简单地将i递增
            while(i <= p2 && nums[i] == 2){
                int temp = nums[i];
                nums[i] = nums[p2];
                nums[p2] = temp;
                p2--;
            }

            // 当前元素为0 移动到数组前面
            if(nums[i] == 0){
                int temp = nums[i];
                nums[i] = nums[p1];
                nums[p1] = temp;
                p1++;
            }
        }

        
    }
}
* 如果l_max小于r_max，说明左侧的最大墙较小，雨水的积累量将由左侧决定（因为水不能越过较高的右侧边界）。此时，计算left位置可以接的雨水量，即l_max - height[left]，然后将left指针向右移动。
* 如果r_max小于或等于l_max，则说明右侧的最大墙较小或等于左侧的最大墙，雨水的积累量将由右侧决定。此时，计算right位置可以接的雨水量，即r_max - height[right]，然后将right指针向左移动。
* 重复步骤3和4，直到left和right指针相遇，此时所有位置的积水量已经计算完成。

* 返回结果：累加过程中计算的积水量res就是函数的返回值


```java
class Solution {
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int l_max = 0;
        int r_max = 0;

        int res = 0;

        while(left < right){

            // 更新左右的最大柱子
            l_max = Math.max(l_max,height[left]);
            r_max = Math.max(r_max,height[right]);

            if(l_max < r_max){
                res += l_max - height[left];// 计算当前值
                left++;
            }else{
                res += r_max - height[right];
                right--;
            }
        }

        return res;
    }
}

```






