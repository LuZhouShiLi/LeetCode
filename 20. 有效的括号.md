# 20. 有效的括号


## 思路总结

解决这个问题的关键是使用栈（Stack）这一数据结构。算法的核心思想是，当遍历到一个左括号时，将其压入栈中；当遍历到一个右括号时，尝试从栈顶弹出一个元素，并检查这个栈顶元素是否与当前的右括号匹配。整个过程遵循后进先出（LIFO）的原则，以确保括号的匹配顺序是正确的。

### 算法步骤

1. **初始化一个栈**：用于存放遇到的左括号。
2. **遍历字符串**：逐个检查字符串中的字符。
   - **如果是左括号**（'('、'{' 或 '['），则直接将其压入栈中。
   - **如果是右括号**（')'、'}' 或 ']'）：
     - 先检查栈是否为空。栈为空意味着没有与之对应的左括号，此时字符串无效，返回 `false`。
     - 若栈不为空，则检查栈顶元素是否与当前右括号匹配。匹配的条件是栈顶元素是与当前右括号对应的左括号。
       - 如果匹配，从栈中弹出栈顶元素。
       - 如果不匹配，说明括号无法形成有效的匹配，返回 `false`。
3. **遍历完成后，检查栈是否为空**：
   - 如果栈为空，说明所有的括号都能找到匹配的另一半，字符串是有效的，返回 `true`。
   - 如果栈不为空，说明有左括号没有被匹配，字符串无效，返回 `false`。

### 辅助方法 `leftOf(char c)`

为了方便地找到与右括号对应的左括号，定义了一个辅助方法 `leftOf(char c)`。该方法根据输入的右括号字符，返回相对应的左括号字符。

- 如果输入是 `'}'`，返回 `'{'`。
- 如果输入是 `')'`，返回 `'('`。
- 如果输入是 `']'`，返回 `'['`。

### 总结

该问题通过使用栈来处理括号的匹配问题，充分利用了栈的“后进先出”的特性，来确保括号的匹配顺序。算法的时间复杂度主要取决于遍历输入字符串的长度，为 O(n)。空间复杂度则取决于栈的使用，最坏情况下（即所有字符都是左括号），也为 O(n)。
