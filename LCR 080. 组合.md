# LCR 080. 组合


## 解题思路

* 初始化一个空的列表 res 来存储所有满足条件的组合，以及一个空的列表 track 来跟踪当前正在构建的组合。

* 定义一个名为 combine 的方法，该方法接受两个参数 n 和 k，分别表示范围和组合的长度。

* 在 combine 方法内部，首先生成一个长度为 n 的整数数组 nums，其中每个元素的值从 1 到 n。

* 调用 backtrack 方法开始生成组合。

* 在 backtrack 方法中，首先检查当前 track 列表的大小是否等于目标长度 k，如果是，则将当前组合添加到 res 中。

* 遍历从 start 开始到数组末尾的所有元素，表示在当前位置做出选择。

* 将选择的元素添加到 track 中，并递归调用 backtrack 方法，传递相同的目标长度 k，但起始位置更新为 i + 1，以确保不会重复选择相同的元素。

* 当递归调用返回后，撤销上一步的选择，即从 track 中移除最后一个元素，以便尝试下一个可能的选择。

* 当遍历完成时，所有满足条件的组合都已经生成，最后将 res 返回作为结果


```java
class Solution {
    List<Integer> track = new LinkedList<>();
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        int[] nums = new int[n];
        for(int i = 0; i < n; i++){
            nums[i] = i + 1;
        }

        backtrack(nums,k,0);
        return res;
    }

    void backtrack(int[] nums,int k,int start){
        // 控制收集大小为k的子集
        if(track.size() == k){
            res.add(new LinkedList<>(track));
        }

        for(int i = start; i < nums.length; i++){
            // 做出选择
            track.addLast(nums[i]);

            // 回溯下一层
            backtrack(nums,k,i + 1);

            // 撤销选择
            track.removeLast();
        }
    }
}

```
