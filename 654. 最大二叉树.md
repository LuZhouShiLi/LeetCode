# 654. 最大二叉树


## 解题思路




* 递归构建： 定义一个递归函数build，该函数接受三个参数：nums数组，当前子数组的左边界left和右边界right。
* 找到最大值： 在当前子数组中找到最大值以及其索引。
* 构造根节点： 使用找到的最大值构造根节点。
* 递归构建左右子树： 递归调用build函数构建左右子树，左子树由左侧子数组构成，右子树由右侧子数组构成。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums,0,nums.length - 1);
    }

    TreeNode build(int[] nums,int left,int right){
        // 首先找到最大值的索引以及最大值

        if(left > right){
            return null;
        }

        int index = -1;
        int maxVal = Integer.MIN_VALUE;
        for(int i = left; i <= right; i++){
            if(maxVal < nums[i]){
                index = i;
                maxVal = nums[i];
            }
        }

        TreeNode root = new TreeNode(maxVal);// 构造根节点
        root.left = build(nums,left,index - 1);// 递归左边
        root.right = build(nums,index + 1,right);// 递归右边

        return root;
    }
}

```