# 435. 无重叠区间


## 方法概述

整体解决方案分为两个部分：

1. `eraseOverlapIntervals(int[][] intervals)`：这是主要方法，用于计算并返回需要移除的区间数量。
2. `intervalSchedule(int[][] intvs)`：这个辅助方法用于通过贪心算法计算出最大的互不重叠区间集合大小。

## 解决思路

### eraseOverlapIntervals 方法

- **输入**：二维数组 `intervals`，表示多个区间。
- **处理**：
  - 获取区间数量 `n`。
  - 调用 `intervalSchedule` 方法计算最大的互不重叠区间集合大小。
  - 通过总区间数减去互不重叠区间的数量，得到需要移除的区间数量。
- **输出**：返回需要移除的区间数量。

### intervalSchedule 方法

- **目标**：找出并计算最大的互不重叠区间集合大小。
- **步骤**：
  1. 检查区间集是否为空，为空则直接返回0。
  2. 使用 `Arrays.sort` 方法和自定义比较器按照区间的结束时间对区间进行升序排序。
  3. 初始化一个变量 `x_end` 来记录当前选中区间的结束时间，以及 `count` 为计数器。
  4. 遍历排序后的区间数组，对于每个区间，如果其开始时间不小于 `x_end`，则将其视为一个互不重叠的区间，并更新 `x_end` 为该区间的结束时间，同时 `count` 加一。
- **结果**：返回计数器 `count` 的值，即最大的互不重叠区间集合的大小。

## 代码复杂度

- **时间复杂度**：O(nlogn)，主要由排序操作决定。
- **空间复杂度**：O(1) 或 O(logn)，取决于排序算法的空间复杂度。



```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int n = intervals.length;
        return n - intervalSchedule(intervals);
    }


    int intervalSchedule(int[][] intvs){
        // 将所有区间按照end升序排序
        if(intvs.length == 0){
            return 0;
        }

        // 排序  升序
        Arrays.sort(intvs,new Comparator<int[]>(){
            public int compare(int[] a,int[] b){
                return a[1] - b[1];
            }
        });


        // 至少有一个区间不相交
        int x_end = intvs[0][1];// 说明是结束最早的区间
        int count = 1;// 这是第一个不相交的区间

        for(int[] interval:intvs){
            int start = interval[0];
            
            // 不相交的区间都是大于等于start
            if(start >= x_end){
                // 说明找到下一个选择区间了 不相交的
                count++;
                x_end = interval[1];// 更新end
            }
        }

        return count;
    }
}

```