# 310. 最小高度树


## 解题思路

* 首先，在方法的开头，创建了一个空的列表res，用于存储最小高度树的根节点。

* 接着，通过条件判断，检查如果图中只有一个节点（即n == 1），则将该节点添加到结果列表中，并返回结果。

* 然后，创建了一个长度为n的整型数组degree，用于存储每个节点的出度。

* 接下来，创建了一个二维列表map，表示图的邻接表，用于存储节点之间的连接关系。对于每个节点，初始化一个空列表。

* 然后，遍历边数组edges，更新节点的出度和邻接表。对于每条边，将边的起始节点和终止节点的出度加1，并将终止节点加入起始节点的邻接表中，将起始节点加入终止节点的邻接表中。

* 接着，创建了一个队列queue，用于执行广度优先搜索。将所有出度为1的叶子节点入队。

* 在队列不为空的情况下，进行循环。在每次循环中，创建一个新的空列表res，用于存储当前层的节点。

* 然后，获取队列的当前大小，表示当前层的节点数。对于当前层的每个节点，将其从队列中取出并添加到res列表中。

* 接着，获取当前节点的邻居节点列表，并遍历这些邻居节点。对于每个邻居节点，将其出度减1，并检查如果其出度变为1，则将其加入队列中，以便下一层的遍历。

* 最后，返回结果列表res，其中包含了所有最小高度树的根节点。

```java

****class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> res = new ArrayList<>();

        // 如果只有一个节点
        if(n == 1){
            res.add(0);
            return res;
        }

        int[] degree = new int[n];// 节点的出度表

        // 建立图关系
        List<List<Integer>> map = new ArrayList<>();
        for(int i = 0; i < n; i++){
            map.add(new ArrayList<>());
        }

        for(int[] edge:edges){
            degree[edge[0]]++;// 边的起始点
            degree[edge[1]]++;// 边的终止点

            map.get(edge[0]).add(edge[1]);
            map.get(edge[1]).add(edge[0]);
        }


        // 建立队列
        Queue<Integer> queue = new LinkedList<>();
        // 所有叶子节点 入队 出度为1的节点 
        for(int i = 0; i < n; i++){
            if(degree[i] == 1){
                queue.offer(i);
            }
        }

        while(!queue.isEmpty()){
            res = new ArrayList<>();
            int size = queue.size();

            for(int i = 0; i < size; i++){
                int cur = queue.poll();
                res.add(cur);

                List<Integer> neighbors = map.get(cur);

                for (int neighbor : neighbors) {
                    degree[neighbor]--;
                    if (degree[neighbor] == 1) {
                        /*如果是叶子节点我们就入队*/
                        queue.offer(neighbor);
                    }
                }

            }
        }

        return res;
    }
}

```