# 1306.跳跃游戏III

## 解题思路

* 从队列中取出一个元素 cur，代表当前访问的位置。
检查 cur 是否超出数组范围，如果是，则跳过当前迭代。
* 如果当前位置 cur 已经被访问过（visited[cur] 为真），同样跳过当前迭代。
* 检查当前位置的值 arr[cur] 是否为0，如果是，说明找到了一条到达值为0的元素的路径，函数返回 true。
* 标记当前位置 cur 为已访问。
* 分别计算当前位置 cur 加上和减去其对应的值 arr[cur] 得到的新位置，并将这些新位置加入到队列中，以便后续访问。


```java
class Solution {
    public boolean canReach(int[] arr, int start) {
        // BFS 搜索
        int n = arr.length;
        boolean[] visited = new boolean[n];// 标记数组

        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);

        while(!queue.isEmpty()){
            int size = queue.size();

            for(int i = 0; i < size; i++){
                int cur = queue.poll();// 队头节点出队

                if(cur < 0 || cur >= arr.length){
                    continue;
                }

                if(visited[cur]){
                    continue;
                }

                if(arr[cur] == 0){
                    return true;
                }
                visited[cur] = true;
                // 将当前位置跳跃到其他位置的索引入队
                queue.offer(arr[cur] + cur);
                queue.offer(cur - arr[cur]);
            } 
        }


        return false;

    }
}

```