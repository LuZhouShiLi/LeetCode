# 22. 括号生成


## 解题思路

* backtrack 方法是递归的核心实现。它接受四个参数：

track：用于记录当前路径的链表。
str：当前生成的括号序列。
left：表示还可以使用的左括号的数量。
right：表示还可以使用的右括号的数量。


* 在 backtrack 方法中，首先检查是否已经没有剩余的左右括号可用，即 left == 0 && right == 0。如果是，将当前生成的括号序列 str 添加到路径记录 track 中，并返回。

* 然后，检查是否还有剩余的左括号可用 (left > 0)，如果有，递归调用 backtrack 方法，并在 str 后面添加一个左括号，同时更新 left 和 right 的值。

* 最后，检查是否还有剩余的右括号可用 (right > 0)，如果有，同样递归调用 backtrack 方法，并在 str 后面添加一个右括号，同时更新 left 和 right 的值。


```java

class Solution {
   
    public List<String> generateParenthesis(int n) {
        LinkedList<String> track = new LinkedList<>();// 记录当前路径

        // left 表示剩余的可用左括号数量。
// right 表示剩余的可用右括号数量
// str表示生成的括号序列
        backtrack(track,"",n,0);
        return track;
    }

    void backtrack(LinkedList<String> track,String str,int left,int right){

        // 计算有没有剩余的左右括号可用 
        // 保证生成括号的有效性 左右括号都是用完毕
        if(left == 0 && right == 0){
            track.add(str);
            return;
        }

        // 如果还有剩余的左括号 str后面添加一个左括号 左括号少一个 需要加上一个右括号
        // left - 1 表示剩余可用的左括号数减少一个，因为已经使用了一个左括号。
// right + 1 表示剩余可用的右括号数增加一个，因为每个左括号都需要匹配一个右括号。
        if(left > 0){
            backtrack(track,str + "(",left - 1,right + 1);
        }

        if(right > 0){
            backtrack(track,str + ")",left,right - 1);
        }
    }
}
```