# LCR 103. 零钱兑换


## 解题思路

* base case： 目标金额amount=0的时候，算法返回0 不需要任何硬币就可以凑出目标金额
* 确定状态：原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断向base case 靠近，所以唯一的状态就是目标金额amount
* 确定选择，也就是导致状态产生变化的行为，每次选择一枚硬币，相当于减少了目标金额
* dp函数/数组的定义：dp数组的元素就是状态转移中会变化的量，也就是说到的状态-目标金额，dp函数的返回值就是题目需要计算的量—硬币数量

```java

class Solution {
    int[] memo;// 备忘录数组
    public int coinChange(int[] coins, int amount) {
        // 初始化备忘录数组
        memo = new int[amount + 1];

        // 将备忘录数组中每一个子问题的解初始化一个不可能的结果
        Arrays.fill(memo,-666);

        return dp(coins,amount);// dp
    }


    int dp(int[] coins,int amount){
        // 首先写出递推的条件
        if(amount == 0){
            return 0;
        }

        if(amount < 0){
            return -1;// 那就是无解的情况
        }

        // 首先查找子问题的解有没有
        if(memo[amount] != -666){
            return memo[amount];
        }

        int res = Integer.MAX_VALUE;

        // 如果子问题没有  遍历所有硬币
        for(int coin:coins){
            // 遍历子问题的解
            int sub = dp(coins,amount - coin);

            // 更新子问题的解
            if(sub == -1){
                continue;
            }

            // 取出最小值
            res = Math.min(res,sub + 1);// 子问题 + 1
        }

        // 将计算结果存入备忘录中
        memo[amount] = (res == Integer.MAX_VALUE) ? -1:res;
        return memo[amount];
    }
}

```




