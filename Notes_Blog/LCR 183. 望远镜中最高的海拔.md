# LCR 183. 望远镜中最高的海拔


## 解题思路

```java

滑动窗口初始化：

创建DQueue实例以表示滑动窗口。
初始化一个空列表（res），用于存储在滑动窗口遍历过程中遇到的最大值。
将变量k设置为指定的限制值。
滑动窗口遍历：

代码使用循环遍历高度数组。
对于前k - 1个元素，它们被添加到滑动窗口（window）中，但不计算最大值。
窗口更新和最大值计算：

一旦滑动窗口填满了k个元素，对于每次迭代，通过添加当前元素并删除最旧元素（保持滑动窗口大小），更新窗口。
使用DQueue类的max方法计算当前窗口内的最大值，并将其添加到结果列表（res）中。
结果汇总：

最终结果从最大值列表（res）中编译成整数数组（arr）。
双端队列实现（DQueue）：

DQueue类被设计为维护单调递减顺序的元素。
push方法将元素添加到队列，确保比新元素小的元素从队列的尾部移除。
max方法从队列的前部检索最大元素。
pop方法从队列的前部移除指定的元素，如果它与队列前部的元素匹配。

```

```java
class Solution {
    public int[] maxAltitude(int[] heights, int limit) {
        DQueue window = new DQueue();// 滑动窗口
        List<Integer> res = new ArrayList<>();// 保存结果
        int k = limit;

        for(int i = 0; i < heights.length; i++){
            if(i < k - 1){
                window.push(heights[i]);// 将窗口前面k - 1个元素填满
            }else{
                window.push(heights[i]);// 窗口向前移动加入新的数

                res.add(window.max());// 记录窗口最大值 每移动一次 记录一次


                // 移除旧的数字 窗口左边的数字
                window.pop(heights[i - k + 1]);
            }
        }

        int[] arr = new int[res.size()];
        for(int i = 0; i < res.size(); i++){
            arr[i] = res.get(i);
        }

        return arr;
    }

    class DQueue{
        LinkedList<Integer> maxq = new LinkedList<>();
        public void push(int n){
            // 将前面小于n得元素全部删除 保证队列是单调递减
            while(!maxq.isEmpty() && maxq.getLast() < n){
                maxq.pollLast();// 队尾删除元素
            }

            maxq.addLast(n);// 队尾添加元素
        }
        // 取出最大值  队头元素
        public int max(){
            return maxq.getFirst();
        }

        // 队头元素出队  
        public void pop(int n){
            if(n == maxq.getFirst()){
                maxq.pollFirst();
            }
        }
    }
}

```

