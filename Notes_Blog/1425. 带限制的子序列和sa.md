# 1425. 带限制的子序列和


## 解题思路


```java

初始化：

初始化数组dp，其中dp[i]表示以第i个元素结尾的满足约束条件的子序列的最大和。
初始化全局最大和ans为整数最小值。
初始化双端队列q用于维护潜在的最大和候选元素的索引。
迭代过程：

使用循环遍历数组nums，并进行如下步骤：
检查队列q是否为空，且队首元素所对应的索引与当前索引的差值是否超过了k，如果是，则将队首元素出队。这保证队列中的元素满足约束条件。
计算以当前元素结尾的子序列的最大和，即dp[i]。这里使用Math.max(0, q.isEmpty() ? 0 : dp[q.peek()]) + nums[i]来确保不包含负值的子序列。
在保持队列单调递减的条件下，将队列中小于等于dp[i]的元素出队，因为它们不可能作为更优的候选元素。
将当前元素的索引加入队列。
更新全局最大和ans为当前最大和dp[i]和ans的较大者。
返回结果：

返回全局最大和ans作为最终结果。
```


```java
class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n];// 记录以每一个元素结尾得最大和
        int ans = Integer.MIN_VALUE;// 记录全局最大和

        // 初始化双端队列q 
        Deque<Integer> q = new ArrayDeque<>();

        for(int i = 0; i < n; i++){

            // 保证队列 单调递减得条件下 将队列中小于或者等于dp[i]得元素出队
            if(!q.isEmpty() && i - q.peek() > k){
                q.poll();// 保证队列元素满足约束条件
            }

            // 计算以当前元素结尾的子序列的最大和
            dp[i] = Math.max(0,q.isEmpty() ? 0:dp[q.peek()])+ nums[i];


            while(!q.isEmpty() && dp[q.peekLast()] <= dp[i]){
                q.pollLast();
            }

            q.offer(i);
            ans = Math.max(ans,dp[i]);
        }

        return ans;
    }
}

```