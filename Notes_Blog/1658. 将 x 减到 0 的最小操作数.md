# 1658. 将 x 减到 0 的最小操作数

## 解题思路

* 计算数组 nums 的总和。
* 将目标和定义为 sum - x。
* 初始化两个映射（need 和 window），用于跟踪所需元素的频率和当前窗口中的元素。
* 初始化指针 left 和 right，表示窗口的边界。
* 使用一个 while 循环将右指针（right）移动以扩展窗口并计算窗口中元素的当前和（currentSum）。
* 使用另一个 while 循环，在当前和大于目标和时通过移动左指针（left）来缩小窗口。
* 检查当前和是否等于目标和，并通过找到满足条件的子数组的最大长度来更新结果（res）。
* 如果右指针达到数组的末尾，移动左指针以继续缩小窗口。
* 最后，返回所需的最小操作次数，即数组长度减去最大子数组长度，如果没有满足条件的子数组则返回 -1。

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        // 寻找最小的子数组-> 找两边最小的元素 也就是寻找  中间最大的元素
        // 使用滑动窗口寻找中间最长的片段sum = sum(nums) - x
        Map<Integer,Integer> need = new HashMap<>();
        Map<Integer,Integer> window =  new HashMap<>();

        int left = 0;
        int right = 0;
        int res = -1;// 记录符合条件的
        int currentSum = 0;
        int sum = Arrays.stream(nums).sum();// 计算数组的和

        while(right < nums.length){
        
            // 窗口进行更新操作  right指针不断向右进行移动
            if(right < nums.length){
                currentSum += nums[right++];
            }

            // 如果发现当前的和已经大于目标sum - x 那么表示需要进行移动左边窗口
            while(currentSum > sum - x && left < nums.length){
                currentSum -= nums[left++];// 缩小左边边界
            }

            if(currentSum == sum -x){
                res = Math.max(res,right - left);
            }

            if(right == nums.length){
                left++;
            }
            
        }

        return res == -1 ? -1:nums.length  - res;
    }
}

```

