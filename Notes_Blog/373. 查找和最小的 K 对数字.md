# 373. 查找和最小的 K 对数字


## 解题思路


* 创建优先级队列： 使用一个最小堆（优先级队列）来存储数对，其排序规则是根据数对的和。通过这种方式，保证每次取出的数对都是当前和最小的。

* 初始化队列： 将nums1数组的所有索引与nums2数组的索引0一起作为初始数对放入队列。

* 循环处理队列： 在循环中，从队列中取出当前和最小的数对，将其加入结果列表。然后，如果nums2数组的索引还没有达到末尾，将索引加1后重新将数对入队。

* 终止条件： 当找到前k小的数对或者队列为空时，结束循环。

* 返回结果： 返回包含前k小数对的结果列表。

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        // 设置一个优先级队列 存储索引[index1,index2]
        // 以确保队列中的元素按照和的大小升序排列。
        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) -> nums1[a[0]] + nums2[a[1]] - (nums1[b[0]] + nums2[b[1]]));

        // 先把nums1的所有索引入队  nums2的索引初始时都是0
        for(int i = 0; i < nums1.length; i++){
            heap.offer(new int[]{i,0});
        }

        List<List<Integer>> ans = new ArrayList<>();
        while(k-- > 0 && !heap.isEmpty()){
            int[] pos = heap.poll();// 元素出队  数对

            ans.add(Arrays.asList(nums1[pos[0]],nums2[pos[1]]));

            if(++pos[1] < nums2.length){
                heap.offer(pos);
            }
        }

        return ans;
    }
}

```