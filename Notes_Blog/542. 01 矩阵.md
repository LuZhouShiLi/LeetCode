# 542. 01 矩阵


## 解题思路

* 初始化一个矩阵 dp 用于存储每个位置的距离，一个矩阵 visited 用于标记每个位置是否被访问过，以及一个队列 queue 用于存储待访问的点。

* 遍历矩阵，将所有为零的位置加入队列，标记为已访问，并将距离设为零。

* 利用BFS算法，从队列中取出一个点，计算其周围四个方向的新坐标，检查是否越界且未被访问过。如果满足条件，更新新位置的距离为当前位置距离加一，并将新位置加入队列，标记为已访问。

* 重复步骤3，直到队列为空，此时所有位置的距离已被计算。

* 返回更新后的矩阵 dp。

这种方法确保了每个位置都被访问一次，且每次访问时都是从最近的零开始扩展，因此得到的距离矩阵即为每个位置到最近的零的距离。这种解法的时间复杂度为 O(m * n)，其中 m 和 n 分别是矩阵的行数和列数。

```java
class Solution {
    int[] dx = {1,0,0,-1};// 左右移动
    int[] dy = {0,1,-1,0};// 上下移动
    int m;
    int n;

    public int[][] updateMatrix(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;

        int[][] dp = new int[m][n];// 存储每一个位置 计算的距离
        boolean[][] visited = new boolean[m][n];// 表示点是否被访问过
        Queue<int[]> queue = new LinkedList<>();// 存储点

        // base case 首先队列存放所有为0的点
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(mat[i][j] == 0){
                    queue.offer(new int[]{i,j});
                    visited[i][j] = true;
                    dp[i][j] = 0;// 标记为0
                }
            }
        }

        // 遍历所有0的位置点  然后对每一个0位置 计算其他四个方向的距离
        while(!queue.isEmpty()){

            int[] cur = queue.poll();
            int x = cur[0];
            int y = cur[1];

            for(int i = 0; i < 4; i++){
                
                // 计算其他四个方向的坐标
                int mx = x + dx[i];
                int my = y + dy[i];

                
                if(mx >= 0 && mx < m && my >= 0 && my < n && !visited[mx][my]){
                    dp[mx][my] = dp[x][y] + 1;
                    queue.offer(new int[]{mx,my});
                    visited[mx][my] = true;
                }

            }
        }

        return dp;
    }
}

```